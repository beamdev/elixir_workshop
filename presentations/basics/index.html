<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link type="text/css" rel="stylesheet" href="workshop.css" />
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-container {
        background-color: #7D7D7D;
      }
      .remark-slide-content {
        <!-- background-color: #DFDFDF; -->
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, top
# Elixir Workshop
### March 2015

.logo.bottom[![Default-aligned image](elixir-logo.png)]

---
class: center, top
### Doug Goldie
.center.bottom[![Middle-aligned image](codcaul-logo-trans-black.png)]
.bottom[##### doug@codecauldron.com]
.bottom[##### github: dgoldie]
???
Notes for the _first_ slide!

---
# Keys to Elixir

###* Modern syntax
###* Dynamic, Functional Language
###* Immutable Data
###* Leverages Erlang VM

---

# Hello World for Elixir
```elixir

defmodule Parallel do

  def pmap(collection, func) do
    collection
    |> Enum.map(&(Task.async(fn -> func.(&1) end))) 
    |> Enum.map(&Task.await/1)
  end

end
```
--
what is a map function?

---
class: center, middle, section
# Basic types and operators

---

# Elixir in Five Minutes

### IEX - interactive shell
```bash

2.1.2 apollo:~/code/work/elixir
$ iex
Erlang/OTP 17 [erts-6.0] [source] [64-bit] [smp:8:8] [async-threads:10] 
[hipe] [kernel-poll:false]

Interactive Elixir (0.14.0) - press Ctrl+C to exit (type h() ENTER for 	help)
	iex(1)>
```
---
### basic math
```bash

	iex(1)> 1 + 2
	3

	iex(2)> 7 - 3
	4

	iex(3)> 4 * 5
	20

	iex(4)> 10 / 2
	5.0

	iex(5)> div(10, 2)
	5

	iex(6)> div 10, 2
	5

	iex(7)> rem 10, 3
	1
```
---


### binary, octal, hex values
```bash
	
	iex(8)> 0b1011
	11

	iex(9)> 0777
	511

	iex(10)> 0x1F
	31
```

---
### booleans

```bash

	iex(28)> true
	true

	iex(29)> false
	false

	iex(30)> is_boolean(true)
	true

	iex(31)> is_boolean(false)
	true
```

everthing is truthy except `false` and `nil`
---




### Atoms
```bash

	iex(13)> :atom
	:atom

	iex(14)> :hello == :world
	false
```

```bash

	iex(13)> true == :true
	true

	iex(14)> is_atom(false)
	true

	iex(14)> is_boolean(:false)
	true
```
Booleans `true` and `false` are in fact `atoms`

---
### Strings
```bash

	"iex(14)> "hello #{:world}"
	"hello world"

	iex(15)> "hello\nworld"
	"hello\nworld"

	iex(17)> is_binary "string"
	true
```

```bash

	"iex(14)> String.length("hello")
	5

	iex(15)> String.upcase "hello"
	"HELLO"
```
---


### lists
```bash
	
	iex(18)> [1,2,3]
	[1, 2, 3]

	iex(38)> [:foo, :bar]
	[:foo, :bar]
  
	iex(36)> [1, 2, 3] ++ [4, 5, 6]
	[1, 2, 3, 4, 5, 6]

	iex(34)> list = [1, 2, 3]
	[1, 2, 3]

	iex(35)> hd list
	1

	iex(36)> hd(list)  
	1

	iex(37)> tl list
	[2, 3]
```
Lists are stored in memory as linked lists.
---

### tuples
```bash

	iex(19)> {:a, :b, :c}
	{:a, :b, :c}

	iex(20)> {:person, "doug", "goldie"}
	{:person, "doug", "goldie"}

	iex> {:ok, "hello"}
	{:ok, "hello"}

	iex> elem(tuple, 1)
	"hello"

	iex> {:error, "bad argument"}
	{:error, "bad argument"}

```
Tuples store elements contiguously in memory.
---

# Operators

```bash

	iex(40)> [1,2,3] ++ [4,5,6]
	[1,2,3,4,5,6]
	
	iex(40)> [1,2,3] -- [2]
	[1,3]
```
Elixir provides ++ and -- to manipulate lists

```bash

	iex(40)> "hello" <> "world"
	"helloworld"
	
	iex(40)> [1,2,3] -- [2]
	[1,3]
```
String concatenation is done with <>

---
# comparison operators

```bash

	iex> true and true
	true

	iex> false or is_atom(:example)
	true
```
The three boolean operators: `or`, `and` and `not` are strict.

```bash

	iex> false and error("This error will never be raised")
	false

	iex> true or error("This error will never be raised")
  true
```
`or` and `and` are short-circuit operators.

There are also `||`, `&&` and `!` which accept arguments of any type.


---

class: center, middle, section
# Pattern matching

---
# Match operator

```bash

	iex> x = 1 
	1

	iex> x
	1
```
--
```bash

	iex> 1 = x
	1
```
--
```bash
	iex> 2 = x
```
--
```bash
	iex> 2 = x
	** (MatchError) no match of right hand side value: 1
```

---
# Match tuples
```bash
	iex> {a, b, c} = {:hello, "world", 42}
	{:hello, "world", 42}

	iex> a
```
--
```bash
	:hello

	iex> b

```
--
```bash
	"world"
	
```
--

```bash
	iex> {:ok, _} = {:ok, 5}
	{:ok, 5}
```

---
# But when things don't match ....
--

##### matching 3 elements with 2 elements
```bash
	iex> {a, b, c} = {:hello, "world"}
```
--
```bash
	** (MatchError) no match of right hand side value: {:hello, "world"}
```
--
##### matching tuple and list
```bash
	iex> {a, b, c} = [:hello, "world", "!"]
```
--
```bash
	** (MatchError) no match of right hand side value: [:hello, "world", "!"]
```

---
### Deconstruct complex structures 
tuples
```bash
	iex> {:ok, result} = {:ok, 13}
	{:ok, 13}
```
--
```bash
	iex> result
	13

```
--
lists
```bash

	iex> [a, b, c] = [1, 2, 3]
	[1, 2, 3]

	iex> a
	1
```
---

# Matching lists

```bash
	iex> [head | tail] = [1, 2, 3]
	[1, 2, 3]
```
get head and tail with `cons` operator: `|`

--
```bash
	iex> head
```
--
```bash
	1

	iex> tail
```
--
```bash
	[2, 3]
```

---
# Rebind variables

```bash
	iex> x = 1
	1
  
	iex> x = 2
```
--
```bash
	2

```

---
# Pin operator: `^`
In matching, you want to match against prior value of variable
```bash
	iex> x = 1
	1
	iex> ^x = 2
	** (MatchError) no match of right hand side value: 2
```
--
```bash
	iex> {x, ^x} = {2, 1}
	{2, 1}
	iex> x
	2

```
---

### Conditionals
case
```bash
	
	iex(3)> x = 1
	1
	iex(4)> case 10 do
	...(4)>   ^x -> "is ten"
	...(4)>   _  -> "is anything"
	...(4)> end
	"is anything"
	iex(5)> 
	
```
cond for different conditions
```bash
	iex(5)> cond do
	...(5)>   1 == 5 -> "nope"
	...(5)>   3 == 3 -> "yep"
	...(5)> end
	"yep"
```
---
# keyword lists

```bash

	iex(40)> [author: "Doug", title: "Elixir Intro"]
	[author: "Doug", title: "Elixir Intro"]
	
```

* They keep the keys ordered as given by the developer.
* They allow a key to be given more than once.
* you can pattern match

???

They keep the keys ordered as given by the developer.
They allow a key to be given more than once.
you can pattern match

---

### maps
```bash

	iex(15)> map = %{:a => 1, 2 => :b} 
	%{2 => :b, :a => 1}

	iex(16)> map[:a]
	1

	iex(17)> map[2] 
	:b
```

* Maps allow any value as key.
* Map keys do not follow any ordering.
---

# Modules

```bash
	iex> String.length "hello"
	5
```
--
```bash
	iex> defmodule Math do
	...>   def sum(a, b) do
	...>     a + b
	...>   end
	...> end

	iex> Math.sum(1, 2)
	3
```
---
# Compilation
Assuming a file "math.ex", you can compile the file:
```bash
	$ elixirc math.ex
```
This will generate a file named `Elixir.Math.beam`

--

Now we can execute it from the shell:
```bash
	iex> Math.sum(1, 2)
	3
```

---

### Libraries
Elixir and Erlang libraries
```bash
	iex(39)> IO.puts "helo"
	helo
	:ok
	iex(40)> :io.format("hello")
	hello:ok
	iex(41)> 
```

Enum
```bash
	iex(41)> list = [1,2,3,4]
	[1, 2, 3, 4]
	iex(42)> Enum.take(list, 2)
	[1, 2]	
	iex(43)> Enum.map(list, fn(x) -> x * 2 end)
	[2, 4, 6, 8]
```
---
### Functions

anonymous
```bash
	iex(33)> add = fn a,b -> a + b end 
	#Function<12.106461118/2 in :erl_eval.expr/5>

	iex(34)> add.(1,2)
	3
```
closures	
```bash
	iex(35)> add_two = fn a -> add.(a, 2) end
	#Function<6.106461118/1 in :erl_eval.expr/5>

	iex(36)> add_two.(4)
	6
```

---
### Functions - capture operator	
```bash
	iex(49)> double = &(&1 * 2)
	#Function<6.106461118/1 in :erl_eval.expr/5>
  
	iex(50)> double.(4)
	8

	iex(51)> fun = &is_atom(&1)
	&:erlang.is_atom/1

	iex(52)> fun.(:atom)
	true
  
```
---
# Looping
Functional languages rely on recursion to write loops.
```elixir
	defmodule Recursion do
	  def print_multiple_times(msg, n) when n <= 1 do
	    IO.puts msg
	  end
	
	  def print_multiple_times(msg, n) do
	    IO.puts msg
	    print_multiple_times(msg, n - 1)
	  end
	end
	
	Recursion.print_multiple_times("Hello!", 3)
	# Hello!
	# Hello!
	# Hello!
```
---
# `Reduce` algorithm
```elixir
	defmodule Math do
	  def sum_list([head|tail], accumulator) do
	    sum_list(tail, head + accumulator)
	  end
	
	  def sum_list([], accumulator) do
	    accumulator
	  end
	end
	
	Math.sum_list([1, 2, 3], 0) #=> 6

```

---

# `Map` algorithm
```elixir
defmodule Math do
	  def double_each([head|tail]) do
	    [head * 2|double_each(tail)]
	  end
	
	  def double_each([]) do
	    []
	  end
	end
	
	Math.double_each([1, 2, 3]) #=> [2, 4, 6]
```

---


### Sigils

Perl Compatible regexes
```bash

  iex(1)> regex = ~r/doug|dan/
	~r/doug|dan/

	iex(2)> "doug" =~ regex
	true

	iex(3)> "dan" =~ regex 
	true

	iex(6)> "xyz" =~ regex   
	false

	iex(7)> "Doug" =~ regex
	false
```

```bash
	
	iex(1)> Regex.replace ~r/[aeiou]/, "Beginning Elixir", "z"
	"Bzgznnzng Elzxzr"

	iex(2)> Regex.match?(~r/foo/, "foo")
	true
```

???
Sigils are one of the mechanisms for working with textual representations
The most common sigil is `~r` used regular expressions

---
### Sigils - strings, char list and word list
```bash

iex(3)> ~s(This is a long sentence.)
"This is a long sentence."

iex(4)> ~c(This is a char list.)
'This is a char list.'

iex(5)> ~w(This is a word list)
["This", "is", "a", "word", "list"]

```
---

Code:

```elixir

def serve_drinks(%User{age: age}) when age >= 21 do
  # Code that serves drinks!
end

serve_drinks User.get("John Doe")
#=> Fails if the user is under 21

```

Code:

```elixir

spawn_link(fn ->
  send parent, {:msg, "hello world"}
end)

# Block until the message is received
receive do
  {:msg, contents} -> IO.puts contents
end
```

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
  highlightLanguage: 'elixir',
  highlightStyle: 'tomorrow-night-blue'
});
    </script>
  </body>
</html>
